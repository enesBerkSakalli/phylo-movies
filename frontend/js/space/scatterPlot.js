import * as THREE from "three";
import { PointGeometryFactory } from "./PointGeometryFactory.js";
import { InteractionManager } from "./InteractionManager.js";
import { UIComponents } from "./UIComponents.js";
import { PositioningAlgorithms } from "./PositioningAlgorithms.js";
import { TreeSelectionService } from "./TreeSelectionService.js";
import { VisualizationRenderer } from "./VisualizationRenderer.js";
import { PointTextureCreator } from "./PointTextureCreator.js"; // Added import

/**
 * @class ScatterPlotVisualizer
 * Represents a 3D scatter plot visualization of phylogenetic tree data.
 * This class handles the setup of the THREE.js scene, rendering of points,
 * user interactions, and provides methods to manipulate the visualization.
 * It can also be used to display the visualization within a WinBox modal using the static `showInModal` method.
 */
class ScatterPlotVisualizer {
  /**
   * Creates an instance of ScatterPlotVisualizer.
   * @param {HTMLElement} container - The DOM element where the visualization canvas will be appended.
   * @param {Array<Object>} [treeList=[]] - The array of tree data objects to visualize. This is the original, unfiltered list.
   * @param {Object} [options={}] - Configuration options for the visualization.
   * @param {number} [options.backgroundColor=0xeeeeee] - Background color of the THREE.js scene.
   * @param {number} [options.pointColor=0x444444] - Default color for the scatter plot points.
   * @param {number} [options.selectedColor=0xe91e63] - Color used to highlight selected points or connections.
   * @param {number} [options.connectionColor=0x444444] - Default color for lines connecting selected points.
   * @param {number} [options.pointSize=0.15] - Default size for the points in the plot.
   * @param {boolean} [options.gridHelper=true] - If true, a grid helper is added to the scene.
   * @param {boolean} [options.axesHelper=true] - If true, an axes helper is added to the scene.
   * @param {boolean} [options.useCustomPositions=true] - If true, attempts to use `options.positions` for point layout.
   * @param {Array<Object>} [options.positions=null] - An array of custom position objects (e.g., `{x, y, z}`) for each point.
   *                                                 If provided and `useCustomPositions` is true, these will be used. These positions should correspond
   *                                                 to the original `treeList` before any filtering by `options.showOnlyFullTrees`.
   * @param {number} [options.layoutSpread=5] - A factor to scale positions generated by layout algorithms (MDS, circular) or custom normalized positions.
   * @param {boolean} [options.showOnlyFullTrees=true] - If true, filters `treeList` based on `TreeSelectionService.filterTrees`
   *                                                  (which currently implements a sampling behavior: "every 5th tree"). This affects which points are rendered
   *                                                  and how `options.positions` are filtered if provided.
   * @param {Array<Array<number>>} [options.distanceMatrix=null] - A distance matrix used for MDS-based positioning if custom positions are not used.
   *                                                              This matrix should correspond to the items after `showOnlyFullTrees` filtering if applicable.
   * @param {boolean} [options.autoRotate=false] - If true, the scene controls will auto-rotate.
   * @param {boolean} [options.showLabels=true] - If true, tooltips with tree information will be shown on hover.
   * @param {number} [options.maxConnections=100] - Maximum number of connections that can be drawn between points.
   * @param {Array<string>} [options.groupColors=null] - An array of hex color strings for coloring points based on group (external logic needed to map groups to these colors).
   * @param {boolean} [options.debugSVG=false] - If true, renders an SVG overlay for debugging final point positions.
   */
  constructor(container, treeList = [], options = {}) {
    /** @property {HTMLElement} container - The DOM element hosting the canvas. */
    this.container = container;
    /** @property {Array<Object>} treeList - The original, unfiltered list of tree data. */
    this.treeList = treeList; // Original treeList passed to the constructor
    this.options = options;

    // Bind event handlers to the class instance to maintain proper 'this' context
    this._handleMouseMove = this._handleMouseMove.bind(this);
    this._handleClick = this._handleClick.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);

    // Configuration settings with defaults that can be overridden
    this.settings = {
      // Visual settings
      backgroundColor: options.backgroundColor || 0xeeeeee,
      pointColor: options.pointColor || 0x444444,
      selectedColor: options.selectedColor || 0xe91e63,
      connectionColor: options.connectionColor || 0x444444,
      pointSize: options.pointSize || 0.15,
      gridHelper: options.gridHelper !== false,
      axesHelper: options.axesHelper !== false,

      // Layout settings
      useCustomPositions: options.useCustomPositions !== false,
      layoutSpread: options.layoutSpread || 5,

      // Filter settings - only show full trees by default
      showOnlyFullTrees: options.showOnlyFullTrees !== false,

      // Data source settings
      distanceMatrix: options.distanceMatrix || null, // This would be for the filtered set if used directly

      // Interaction settings
      autoRotate: options.autoRotate !== undefined ? options.autoRotate : false,
      showLabels: options.showLabels !== false,
      maxConnections: this.options.maxConnections || 100,
    };

    // Filter trees to only include full trees if requested
    const { filteredTreeList, treeIndices: originalFilteredTreeIndices } = TreeSelectionService.filterTrees(
      this.treeList, // Use the original treeList from constructor
      this.settings.showOnlyFullTrees
    );
    this.treeIndices = originalFilteredTreeIndices; // Store for use in InteractionManager & highlightTree

    // numPoints is the number of points we will actually render
    this.numPoints = filteredTreeList.length;

    // Initialize THREE.js scene, camera, renderer
    const { renderer, scene, camera, controls } =
      VisualizationRenderer.initialize(this.container, this.settings);
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.controls = controls;

    // Generate positions for the points by calling the refactored function
    this.positions = PositioningAlgorithms.prepareScatterPlotPositions(
      this.settings.useCustomPositions ? this.options.positions : null,
      this.settings.distanceMatrix,
      this.settings.layoutSpread,
      this.numPoints, // numPointsToRender
      this.settings.showOnlyFullTrees, // This flag guides how sourcePositions are filtered IF provided
      this.treeList.length, // originalSourcePositionsLength
      this.treeIndices // filteredSourceIndices
    );

    // The SVG debug logic
    // called from here with the 'positions' or intermediate arrays, or be part of a debug mode
    // in prepareScatterPlotPositions. For this refactor, it's assumed to be part of the moved logic
    // or handled separately if still required for debugging.
    // The original SVG debug logic used 'relevantPositionsSource' which is now internal to prepareScatterPlotPositions.
    // If direct SVG debugging of the final THREE.js `positions` array is needed here:
    if (options.debugSVG && !document.getElementById("embedding-debug-svg")) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.id = "embedding-debug-svg";
      svg.style.position = "absolute";
      svg.style.top = "0";
      svg.style.right = "0";
      svg.style.width = "200px";
      svg.style.height = "200px";
      svg.style.background = "rgba(255,255,255,0.7)";
      svg.style.zIndex = "9999";
      svg.style.pointerEvents = "none";
      if (this.container && this.container.appendChild) {
          this.container.appendChild(svg);
      }

      const tempPoints = [];
      for (let i = 0; i < this.numPoints; i++) {
          tempPoints.push({ x: this.positions[i*3], y: this.positions[i*3+1]});
      }
      let xs = tempPoints.map(p => p.x);
      let ys = tempPoints.map(p => p.y);
      if (xs.length > 0 && ys.length > 0) {
          let minX = Math.min(...xs), maxX = Math.max(...xs);
          let minY = Math.min(...ys), maxY = Math.max(...ys);
          let rangeX = maxX - minX;
          let rangeY = maxY - minY;

          // Avoid division by zero if all points are collinear or identical
          if (rangeX === 0 && rangeY === 0) { // All points are the same
              // Plot all points at the center
              tempPoints.forEach(() => {
                  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                  circle.setAttribute("cx", "100"); // Center of 200px SVG
                  circle.setAttribute("cy", "100");
                  circle.setAttribute("r", 2);
                  circle.setAttribute("fill", "#4285f4");
                  svg.appendChild(circle);
              });
          } else if (rangeX === 0) { // Points are collinear vertically
               let scaleY = 180 / rangeY || 1;
               tempPoints.forEach(p => {
                  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                  circle.setAttribute("cx", "100"); // Center X
                  circle.setAttribute("cy", ((p.y - minY) * scaleY + 10).toFixed(2));
                  circle.setAttribute("r", 2);
                  circle.setAttribute("fill", "#4285f4");
                  svg.appendChild(circle);
              });
          } else if (rangeY === 0) { // Points are collinear horizontally
              let scaleX = 180 / rangeX || 1;
              tempPoints.forEach(p => {
                  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                  circle.setAttribute("cx", ((p.x - minX) * scaleX + 10).toFixed(2));
                  circle.setAttribute("cy", "100"); // Center Y
                  circle.setAttribute("r", 2);
                  circle.setAttribute("fill", "#4285f4");
                  svg.appendChild(circle);
              });
          } else { // Default case
              let scaleX = 180 / rangeX;
              let scaleY = 180 / rangeY;
              tempPoints.forEach(p => {
                  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                  circle.setAttribute("cx", ((p.x - minX) * scaleX + 10).toFixed(2));
                  circle.setAttribute("cy", ((p.y - minY) * scaleY + 10).toFixed(2));
                  circle.setAttribute("r", 2);
                  circle.setAttribute("fill", "#4285f4");
                  svg.appendChild(circle);
              });
          }
      }
    }

    // Create point texture for better looking points
    this.pointTexture = PointTextureCreator.createPointTexture();

    // Prepare colors if group coloring is provided
    let colorMapper;
    if (this.options.groupColors && Array.isArray(this.options.groupColors)) {
      colorMapper = this.options.groupColors.map((color) => new THREE.Color(color));
    }

    // Create geometry for points
    // Note: PointGeometryFactory.createGeometry returns 'indices' which are the true mapping from
    // the geometry's sorted/internal indices to the original treeIndices after filtering.
    // We stored the treeIndices from TreeSelectionService.filterTrees as this.treeIndices earlier.
    // For highlighting by original tree index, this.treeIndices should be used by InteractionManager.
    const { geometry, colors, sizes, indices: geomPointToFilteredTreeIdxMap } =
      PointGeometryFactory.createGeometry(
        this.positions,
        this.numPoints,
        this.treeIndices, // Pass the originalFilteredTreeIndices here
        this.settings.pointSize,
        colorMapper
      );
    this.geometry = geometry;
    this.colors = colors; // Storing for direct manipulation in clearHighlights, highlightTree
    this.sizes = sizes;   // Storing for direct manipulation

    // Create material and points
    this.pointsMaterial = PointGeometryFactory.createPointsMaterial(
      this.settings.pointSize,
      this.pointTexture
    );

    this.points = new THREE.Points(this.geometry, this.pointsMaterial);
    this.scene.add(this.points);

    // Create UI elements (info panel, tooltip)
    this.infoPanel = UIComponents.createInfoPanel(
      this.container,
      this.numPoints,
      (newSize) => { // onSizeChange callback
        this.settings.pointSize = newSize;
        for (let i = 0; i < this.numPoints; i++) {
          this.sizes[i] = newSize; // Assumes this.sizes is the array from createGeometry
        }
        this.geometry.attributes.size.needsUpdate = true;
        this.pointsMaterial.size = newSize;
        this.pointsMaterial.needsUpdate = true;
      }
    );

    this.tooltip = UIComponents.createTooltip(this.container);
    this.compareButton = this.infoPanel.querySelector("#compare-connection-btn");
    this.compareButton.style.display = "none";

    // Create selection marker
    this.selectionMarker = UIComponents.createSelectionMarker(
      this.settings.selectedColor
    );
    this.scene.add(this.selectionMarker);
    this.selectionMarker.visible = false;

    this.comparisonModals = {}; // Managed locally

    // Instantiate InteractionManager
    this.interactionManager = new InteractionManager(
      this.scene,
      this.camera,
      this.points,
      this.geometry,
      this.settings,
      this.selectionMarker,
      this.compareButton,
      geomPointToFilteredTreeIdxMap, // Pass the map from geometry index to filtered tree index
      this.positions
    );

    // Add debug logging to track geometry and positions data
    console.log("ScatterPlotVisualizer constructor - numPoints:", this.numPoints);
    console.log("ScatterPlotVisualizer constructor - positions array length:", this.positions ? this.positions.length : 0);
    console.log("ScatterPlotVisualizer constructor - geometry attributes:", this.geometry.attributes);

    // Start animation loop and event listeners after all setup is complete
    this._startAnimationLoop();
    this._setupEventListeners();
}

  // The rest of the event handlers remain unchanged, but they'll now have the correct context:
  _handleMouseMove(event) {
    this.interactionManager.onMouseMove(event, this.container, this.tooltip);
  }

  _handleClick(event) {
    if (event.shiftKey) {
      this._toggleConnectionDebug(this.scene, this.interactionManager.connectionLines);
      return;
    }
    this.interactionManager.handleConnectionClick(event, this.container);
    if (!this.interactionManager.getSelectedConnectionInfo()) {
      this.interactionManager.handlePointClick(event, this.container);
    }
  }

  _onWindowResize() {
    VisualizationRenderer.updateOnResize(this.renderer, this.camera, this.container);
  }

  _setupEventListeners() {
    this.container.addEventListener("mousemove", this._handleMouseMove);
    this.container.addEventListener("click", this._handleClick);
    this.compareButton.addEventListener("click", () => {
      const currentSelectedConnection = this.interactionManager.getSelectedConnectionInfo();
      if (currentSelectedConnection) {
        TreeSelectionService.compareTrees(
          currentSelectedConnection.tree1,
          currentSelectedConnection.tree2,
          { treeList: this.treeList, comparisonModals: this.comparisonModals }
        );
      }
    });
    window.addEventListener("resize", this._onWindowResize);
  }


  _startAnimationLoop() {
    VisualizationRenderer.startAnimation(() => {
      this.controls.update();
      if (this.selectionMarker.visible) {
        this.selectionMarker.rotation.y += 0.02;
        const time = Date.now() * 0.003;
        const scale = 1 + 0.2 * Math.sin(time);
        this.selectionMarker.scale.set(scale, scale, scale);
      }
      this.renderer.render(this.scene, this.camera);
    });
  }

  // Add a debug tool to visualize connections and hit areas
  // This becomes a private method
  _toggleConnectionDebug(scene, connectionLines) {
    const existingDebug = scene.getObjectByName("connection-debug");
    if (existingDebug) {
      scene.remove(existingDebug);
      return;
    }

    // Create a debug helper group
    const debugHelper = new THREE.Group();
    debugHelper.name = "connection-debug";

    // Visualize all hit areas with different colors
    connectionLines.forEach((line, i) => {
      if (line.userData && line.userData.isHitArea) {
        // Create visible version of hit area
        const debugMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(i / connectionLines.length, 1, 0.5),
          transparent: true,
          opacity: 0.4,
          side: THREE.DoubleSide,
        });

        // Clone the hit area's geometry
        let debugMesh;
        if (line instanceof THREE.Mesh) {
          debugMesh = new THREE.Mesh(line.geometry.clone(), debugMaterial);
        } else {
          debugMesh = new THREE.Line(line.geometry.clone(), debugMaterial);
        }

        // Add to debug helper
        debugHelper.add(debugMesh);
      }
    });

    scene.add(debugHelper);
  }

  // Public Interface Methods

  /**
   * Initiates a comparison between two trees specified by their original indices using `TreeSelectionService`.
   * It constructs a `guiSettings` object, potentially drawing some values from `window.gui`
   * (as a temporary measure during refactoring) or using defaults, to pass to the comparison service.
   * @param {number} tree1Index - The original index (from the initial `this.treeList`) of the first tree to compare.
   * @param {number} tree2Index - The original index (from the initial `this.treeList`) of the second tree to compare.
   */
  compareTrees(tree1Index, tree2Index) {
    // Populate guiSettings. Some values might still come from window.gui temporarily,
    // or from this.settings or this.options if available and appropriate.
    const guiSettings = {
      fontSize: window.gui?.fontSize || 12, // Example: Access global or use a default
      leaveOrder: window.gui?.leaveOrder || [], // Example
      toBeHighlighted: window.gui?.toBeHighlighted || {}, // Example
      ignoreBranchLengths: window.gui?.ignoreBranchLengths || false, // Example
      strokeWidth: window.gui?.strokeWidth || 1 // Example
      // Add other properties from window.gui that drawSpecificTrees might need
    };

    TreeSelectionService.compareTrees(tree1Index, tree2Index, {
      treeList: this.treeList, // Use instance's treeList
      comparisonModals: this.comparisonModals,
      guiSettings: guiSettings
    });
  }

  /**
   * Highlights a specific tree in the scatter plot by changing its color and size,
   * and animates the camera to focus on it.
   * @param {number} treeIndex - The original index of the tree (from the initial, unfiltered `this.treeList`) to highlight.
   */
  highlightTree(treeIndex) {
    // this.interactionManager.treeIndices maps the geometry vertex index (0 to numPoints-1)
    // to the original treeList index.
    // We need to find the geometry index that corresponds to the original treeIndex.
    let geometryIndex = -1;
    for(let i=0; i < this.interactionManager.treeIndices.length; ++i) {
        if (this.interactionManager.treeIndices[i] === treeIndex) {
            geometryIndex = i;
            break;
        }
    }

    if (geometryIndex !== -1 && geometryIndex < this.numPoints) {
        const color = new THREE.Color(this.settings.selectedColor);
        this.geometry.attributes.color.setXYZ(geometryIndex, color.r, color.g, color.b);
        this.geometry.attributes.size.setX(geometryIndex, this.settings.pointSize * 1.5);
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.attributes.size.needsUpdate = true;

        const pointPosition = new THREE.Vector3(
            this.positions[geometryIndex * 3],
            this.positions[geometryIndex * 3 + 1],
            this.positions[geometryIndex * 3 + 2]
        );

        // Animate camera (simplified, could be more elaborate)
        const targetPosition = pointPosition.clone().add(new THREE.Vector3(0,0,7)); // Look from a bit further
        this.camera.position.lerp(targetPosition, 0.1); // Smooth transition
        this.controls.target.lerp(pointPosition, 0.1);
    }
  }

  /**
   * Clears all visual highlights from points, resetting them to their default colors and sizes.
   * Also hides the selection marker and resets the `selectedPoint` state in the `InteractionManager`.
   */
  clearHighlights() {
    for (let i = 0; i < this.numPoints; i++) {
      // this.interactionManager.treeIndices[i] provides the original tree index for the point at geometry index i
      const defaultColor = PointGeometryFactory.getDefaultColorForPoint(i, this.numPoints, this.interactionManager.treeIndices[i]);
      this.geometry.attributes.color.setXYZ(i, defaultColor.r, defaultColor.g, defaultColor.b);
      this.geometry.attributes.size.setX(i, this.settings.pointSize);
    }
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
    if (this.interactionManager.selectedPoint) this.interactionManager.selectedPoint = null;
    this.interactionManager.selectionMarker.visible = false;
  }

  /**
   * Clears all connections drawn between points by delegating this action to the `InteractionManager`.
   */
  clearConnections() {
    this.interactionManager.clearConnections();
  }

  /**
   * Updates the positions of the points in the scatter plot.
   * The new positions are scaled by `this.settings.layoutSpread`. The input `newPositions`
   * should correspond to the currently rendered points (i.e., its length must match `this.numPoints`).
   * @param {Array<Object>} newPositions - An array of new position objects (e.g., `{x, y, z}`).
   */
  setPositions(newPositions) {
    if (!newPositions || newPositions.length !== this.numPoints) {
      console.error("Invalid new positions array or length mismatch with current number of points.");
      return;
    }
    for (let i = 0; i < this.numPoints; i++) {
      this.positions[i * 3] = newPositions[i].x * this.settings.layoutSpread;
      this.positions[i * 3 + 1] = newPositions[i].y * this.settings.layoutSpread;
      this.positions[i * 3 + 2] = (newPositions[i].z || 0) * this.settings.layoutSpread;
    }
    this.geometry.attributes.position.needsUpdate = true;
  }

  /**
   * Cleans up resources used by the visualization. This includes removing event listeners,
   * disposing of THREE.js geometries, materials, and textures, clearing connections,
   * and removing any DOM elements created by the visualizer (tooltip, infoPanel).
   * It is important to call this method when the visualization is no longer needed to prevent memory leaks.
   */
  dispose() {
    // Remove event listeners
    window.removeEventListener("resize", this._onWindowResize);
    this.container.removeEventListener("mousemove", this._handleMouseMove);
    this.container.removeEventListener("click", this._handleClick);

    if (this.tooltip && this.tooltip.parentNode) this.tooltip.parentNode.removeChild(this.tooltip);
    if (this.infoPanel && this.infoPanel.parentNode) this.infoPanel.parentNode.removeChild(this.infoPanel);

    this.interactionManager.clearConnections(); // Clear any lines/hitareas from scene via manager
    this.scene.remove(this.points);
    this.scene.remove(this.selectionMarker);

    this.geometry.dispose();
    this.pointsMaterial.dispose();
    if (this.pointTexture) this.pointTexture.dispose();

    // Dispose renderer if it's managed per instance and not globally
    // this.renderer.dispose(); // Depends on how renderer is managed

    console.log("ScatterPlotVisualizer disposed.");
  }

  /**
   * Programmatically selects a connection identified by `connectionId` by delegating
   * to the `InteractionManager`.
   * @param {string} connectionId - The ID of the connection to select (typically in the format "treeIndex1-treeIndex2").
   * @returns {boolean} True if the connection was found and selected, false otherwise.
   */
  selectConnection(connectionId) {
    return this.interactionManager.selectConnectionById(connectionId);
  }

  /**
   * Static method to create and display the scatter plot visualization within a WinBox modal.
   * This method handles asynchronous loading of positioning algorithms, data preparation based on
   * the selected mode (e.g., "umap" vs. other), modal window creation, and instantiation of the `ScatterPlotVisualizer`.
   *
   * @param {Object} params - The parameters for creating and showing the modal.
   * @param {Array<Object>} params.realTreeList - The complete, unfiltered list of tree data, typically used if `mode` is 'umap'.
   * @param {Array<Object>} params.treeList - A potentially pre-filtered list of tree data, used if `mode` is not 'umap'.
   * @param {Array<Object>} [params.initialEmbedding=null] - Pre-calculated positions (e.g., from UMAP analysis) corresponding to `realTreeList`.
   * @param {Object} params.modals - An object used to manage and store references to active WinBox modals. This object will be updated.
   * @param {Function} params.setModals - A callback function that is called to update the `modals` manager object with the new scatter plot modal instance.
   */
  static showInModal({ realTreeList, treeList, initialEmbedding, modals, setModals }) {
    // 1. Show loading indicator
    const loadingIndicator = document.createElement("div");
  loadingIndicator.className = "loading-indicator";
  loadingIndicator.innerHTML =
    '<div class="spinner"></div><div>Loading Tree Space Visualization...</div>';
  Object.assign(loadingIndicator.style, {
    position: "fixed",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    padding: "20px",
    background: "white",
    borderRadius: "5px",
    boxShadow: "0 0 10px rgba(0,0,0,0.2)",
    zIndex: "10000",
  });
  document.body.appendChild(loadingIndicator);

  // 2. Prepare data and modal
  const modeSelector = document.getElementById("scatter-plot-mode");
  const mode = modeSelector ? modeSelector.value : "umap";
  let treeListForScatter;
  let positionsToPassToCreate; // Renamed to avoid confusion with 'positions' variable used by createScatterPlot options
  let showOnlyFullTreesOption; // For createScatterPlot options
  let sourcePositionsForPrepare;
  let numPointsToRenderForPrepare;
  let originalSourcePositionsLengthForPrepare;
  let filteredSourceIndicesForPrepare;
  let showOnlyFullTreesForPrepare; // Parameter for prepareScatterPlotPositions

  import("./PositioningAlgorithms.js").then(({ PositioningAlgorithms }) => {
    if (mode === "umap") {
      treeListForScatter = realTreeList; // UMAP mode uses the full, unfiltered realTreeList
      showOnlyFullTreesOption = true; // createScatterPlot will be told to show all, as filtering is implicit in UMAP context

      sourcePositionsForPrepare = initialEmbedding; // Use the passed initialEmbedding
      numPointsToRenderForPrepare = realTreeList.length;
      showOnlyFullTreesForPrepare = true; // prepareScatterPlotPositions should use all data from initialEmbedding
      originalSourcePositionsLengthForPrepare = realTreeList.length; // Assuming initialEmbedding corresponds to realTreeList
      filteredSourceIndicesForPrepare = Array.from({ length: realTreeList.length }, (_, i) => i); // Identity mapping

      // Validate initialEmbedding structure
      if (
        !initialEmbedding ||
        !Array.isArray(initialEmbedding) ||
        initialEmbedding.length !== realTreeList.length ||
        !initialEmbedding.every((p) => typeof p === "object" && "x" in p && "y" in p) // z is optional
      ) {
        console.warn("[showScatterPlotModal] Invalid or mismatched initialEmbedding for UMAP mode. Falling back for sourcePositions.");
        sourcePositionsForPrepare = null; // Force fallback within prepareScatterPlotPositions
      }

    } else { // E.g., "mds" or other modes that might use the potentially filtered 'treeList'
      treeListForScatter = treeList;
      showOnlyFullTreesOption = false; // Or derive from settings if this mode also has filtering

      sourcePositionsForPrepare = null; // No predefined embedding for these modes
      numPointsToRenderForPrepare = treeList.length;
      showOnlyFullTreesForPrepare = false; // Reflects that we are using the 'treeList' which might be pre-filtered by other means
      originalSourcePositionsLengthForPrepare = treeList.length;
      filteredSourceIndicesForPrepare = Array.from({ length: treeList.length }, (_, i) => i);
    }

    // Call prepareScatterPlotPositions to get the final positions array
    positionsToPassToCreate = PositioningAlgorithms.prepareScatterPlotPositions(
      sourcePositionsForPrepare,
      null, // distanceMatrix - not used directly in this modal's logic currently, would be part of options if needed
      5,    // layoutSpread - default or from settings
      numPointsToRenderForPrepare,
      showOnlyFullTreesForPrepare,
      originalSourcePositionsLengthForPrepare,
      filteredSourceIndicesForPrepare
    );

    // 3. Remove loading indicator
    if (document.body.contains(loadingIndicator)) {
      document.body.removeChild(loadingIndicator);
    }

    // 4. Create modal container
    const modalContainer = document.createElement("div");
    modalContainer.style.width = "100%";
    modalContainer.style.height = "100%";
    modalContainer.style.overflow = "hidden";

    // 5. Create WinBox modal
    const modal = new WinBox({
      title: "Phylogenetic Tree Space Visualization",
      width: "90%",
      height: "90%",
      x: "center",
      y: "center",
      background: "#373747",
      class: ["no-full"],
      mount: modalContainer,
    });

    if (!modals) modals = {};
    modals.scatterPlot = modal;
    setModals(modals);

    // 6. Render scatter plot after a short delay
    setTimeout(() => {
      // Instantiate the ScatterPlotVisualizer class
      const scatterPlotInstance = new ScatterPlotVisualizer(
        modalContainer,
        treeListForScatter,
        {
          positions: positionsToPassToCreate,
          showOnlyFullTrees: showOnlyFullTreesOption,
          // Pass other relevant options for scatter plot appearance/behavior
          backgroundColor: 0x202030, // Dark background for modal
          pointColor: 0x4285f4,      // Default point color
          selectedColor: 0xff5722,
          pointSize: 0.2,
          autoRotate: true,
          // groupColors: ... (add if needed)
        }
      );
      modal.onclose = () => {
        delete modals.scatterPlot;
        setModals(modals);
      };
    }, 100);
  }).catch((error) => {
    if (document.body.contains(loadingIndicator)) {
      document.body.removeChild(loadingIndicator);
    }
    const notification = document.createElement("div");
    notification.className = "notification error";
    notification.innerHTML = `
      <div class="notification-content">
        <i class="fa fa-exclamation-triangle"></i>
        <span>Failed to load tree visualization: ${error.message}</span>
      </div>
    `;
    document.body.appendChild(notification);
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 5000);
  });
  }
}

const showScatterPlotModal = ScatterPlotVisualizer.showInModal;
export { ScatterPlotVisualizer, showScatterPlotModal };
