Metadata-Version: 2.1
Name: brancharchitect
Version: 0.37.0
Summary: 
Author: Your Name
Author-email: you@example.com
Requires-Python: >=3.11,<4.0
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Dist: numpy (>=1.26.4,<2.0.0)
Requires-Dist: pydantic (>=2.0,<3.0)
Description-Content-Type: text/markdown


# Methods

Imagine you’re comparing two family trees, each drawn by a different relative, and you want to know: what’s the smallest set of people you could “remove” so that both trees tell the same story? In evolutionary biology, these “people” are called leaves, and the ones that cause the trees to disagree are known here as **discordant leaves**—the species or elements whose positions create a mismatch between the trees. The challenge is to find the smallest set of discordant leaves whose removal would make the trees compatible, a process we call **reconciliation**.

A naïve approach is to try every possible group of leaves, remove them one by one, and check if the trees match. This brute-force method quickly becomes hopeless as the family grows: the number of possible groups explodes, and you spend all your time checking combinations that don’t help. The heart of the problem is the **conflict**—a spot where the two trees disagree about how to group their leaves. Each conflict is a local mismatch, a place where the trees’ stories diverge.

Let’s refine our approach, step by step:
1. **Spot the Disagreements:** First, scan both trees to find all the conflicts—those places where the groupings of leaves differ. These are the only places that matter for reconciliation.
2. **Zoom In:** For each conflict, build a compact table (a “conflict matrix”) that shows which leaves are responsible for the disagreement. This matrix is like a puzzle board, highlighting the troublemakers.
3. **Divide and Conquer:** If a conflict splits into independent subproblems, solve each one separately. Smaller puzzles are always easier to solve.
4. **Systematic Search:** For each matrix, use a structured process to find all minimal sets of discordant leaves whose removal would resolve the conflict—never checking the same group twice.
5. **Track Progress:** After each fix, update the trees and repeat, always working with the latest state. If new conflicts appear, tackle them in turn.
6. **Iterate if Needed:** Continue this process until all conflicts are gone and the trees are finally in harmony.

Mathematically, each tree can be described by its set of **splits**—bipartitions of the leaf set. A conflict occurs when a split in one tree is not present in the other. The algorithm seeks a minimal set $S \subseteq L$ (where $L$ is the set of all leaves) such that, after removing $S$ from both trees, the remaining splits in both trees are identical:

$$
\text{Find minimal } S \subseteq L \text{ such that } \text{Splits}(T_1 \setminus S) = \text{Splits}(T_2 \setminus S)
$$

The conflict matrix for each disagreement encodes which leaves must be removed to resolve that particular mismatch, and the algorithm efficiently searches for the smallest such sets.

The final algorithm works like a detective with a stack of case files. It starts by listing all the disagreements between the two trees. For each, it builds a conflict matrix that encodes the incompatibilities. It then splits the problem into smaller pieces if possible, and for each, systematically finds the smallest sets of discordant leaves whose removal would resolve the issue. After each solution, it updates the trees and the list of conflicts, repeating as needed until all are resolved. The result is a collection of minimal edits that, together, reconcile the two histories.

This approach reduces the worst-case time from exponential to polynomial in the number of leaves and conflicts—typically $O(n^3)$, where $n$ is the number of leaves. (In plain terms: it’s fast enough for real family trees, even if they’re big.) This matters because it transforms a slow, repetitive process into a swift, scalable one—crucial for large datasets or interactive applications.

The same idea generalizes to any situation where two hierarchical structures must be reconciled by minimal edits—organizational charts, file system trees, or even document outlines. By focusing on local conflicts, breaking them into independent parts, and systematically searching for minimal fixes, we can efficiently solve problems that would otherwise be out of reach. In the end, reconciliation is about finding peace between two stories—one discordant leaf at a time.

